# rough scratch file for language syntax ideas
# most of these are not valid lunary code snippets

# constant definition block
::(
  title: "default",
  category: "resources",
  math: &Maths
)

# nested function chaining
/> page ::title
/> page "second"
  |/> md "A collection of works which I vastly enjoy, some of which I consider as being *timeless*. These works have had a significant impact on my creative output, and I often turn to them for inspiration."
  |/> img "hungry-rabbits"
  |/> \> (ctx, tag) -> (

  )

# list accessors
[1, 2, 3] at 1
[1, 2, 3] at 1~2
[1, 2, 3] at [0,2]

# invoke function without params
/> page ::title

# function chaining
vis?
  |> md "visible page" 
  |> ex ::title 
  |> "title"

# invoke function without params and pass anonymous function
/> each ::tags \> (tag) -> (tag)

# function call returning a map
\> page (param, param2) -> (
  {
    "a":"fblock",
    "b": nil,
    "c": 0
  }
)

# dependency import
dep math.lun 

# 0-arity function
fn values -> (
  [0,1,2,3,4]
)

# map definition
map = (a: -1, b: 2)

# inline function definition
add = fn (value, some) -> (value + some)
some = 10

# nested function definition
map = fn (value, function) -> (
  fn at (enum, position) -> (enum at position)

  iter = 0
  if (i <= length(enum)) -> (
    at(value, ) 
  )
)

# function chaining experiments

result = (a: -1, b: 2)
  |> @lib/map:each_value 
  |> add_some ::max

result2 = ::defined_values 
  |> map fn i -> (i + 1)

result3 = ::defined_values 
  |> fn -> (i + [3])

result4 = ::defined_values 
  |> map add_one
:ok

# map access experiments
map = (a: "value", "bee": )
key = 
map at :a
